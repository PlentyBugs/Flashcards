type: edu
custom_name: stage6
files:
- name: test/common/DialogClue.kt
  visible: false
  text: |
    package common

    import org.hyperskill.hstest.v6.testcase.CheckResult
    import org.hyperskill.hstest.v6.testcase.TestCase


    // ---- DialogClue ----

    /** May be several lines or just one. */
    interface Phrase {
        fun toPhraseLines(): List<PhraseLine>
    }

    /** list of input and output lines, combined together. */
    fun compositePhrase(block: () -> List<Phrase>) = object : Phrase {
        override fun toPhraseLines() = block().flatMap { it.toPhraseLines() }
    }

    fun compositePhrase(vararg phrases: Phrase) = object : Phrase {
        override fun toPhraseLines() = phrases.flatMap { it.toPhraseLines() }
    }

    /** Either user (input) or output phrase. Each phrase should be a line. */
    sealed class PhraseLine : Phrase {
        override fun toPhraseLines() = listOf(this)
    }

    /** Some mutable data, that is passed across dialog phrases. */
    class Context {
        val rawData = mutableMapOf<String, Any>()
    }

    class UserLine(val text: String, val updateContext: CtxUpdate = {}) : PhraseLine() {

    }
    typealias CtxUpdate = (ctx: Context) -> Unit

    class OutputLine(val checker: (text: String, ctx: Context) -> CheckResult) : PhraseLine()

    /** This function creates a line with user input (our test input).
     *
     * Unfortunately we can't access the Context, when we adding user text.
     * This occurs because of HS test framework limitations:
     * we need to pass all inputs first, and then start checking outputs. */
    fun user(text: String, updateContext: (ctx: Context) -> Unit = {}) = UserLine(text, updateContext)

    fun anyLine(updateContext: CtxUpdate = {}) = OutputLine { _, ctx -> CheckResult.TRUE.also { updateContext(ctx) } }

    fun containing(
            vararg parts: String,
            ignoreCase: Boolean = true,
            hint: String? = null,
            updateContext: CtxUpdate = {}
    ) = OutputLine { line, context ->
        fun buildFeedback(): String {
            val feedback = StringBuilder()
            feedback.append("Your line\n`$line`\nshould contain ${parts.joinToString("`, `", "`", "`")}")
            if (ignoreCase) {
                feedback.append(" (ignoring case)")
            }
            feedback.append(".")
            if (hint != null) {
                feedback.append("\n$hint")
            }
            return feedback.toString()
        }

        var startIndex = 0
        for (part in parts) {
            startIndex = line.indexOf(part, startIndex, ignoreCase)
            if (startIndex == -1) {
                return@OutputLine CheckResult.FALSE(buildFeedback())
            }
        }
        updateContext(context) // everything is correct, update context
        CheckResult.TRUE
    }

    class DialogClue(private val phrases: List<PhraseLine>) {

        private val inputPhrases = phrases.filter { it is UserLine }.map { it as UserLine }
        private val outputPhrases = phrases.filter { it is OutputLine }.map { it as OutputLine }

        fun generateInput() = inputPhrases
                .joinToString("\n", postfix = "\n") { it.text }

        fun checkOutput(output: String): CheckResult {
            val lines = output.lines()
                    .filter { it.isNotBlank() }

            fun wrongOutputSizeFeedback() = CheckResult.FALSE("The number of lines in your output is ${lines.size}, " +
                    "but it should be ${outputPhrases.size}. " +
                    "Check, that you output your lines with println, not print. And there are no extra outputs.\n\n" +
                    mergeInputAndOutput(lines))

    // here we store some mutable data from phrase to phrase
            val context = Context()

            val lineIter = lines.listIterator()
            phrases.forEach { phraseLine ->
                when (phraseLine) {
                    is UserLine -> phraseLine.updateContext(context)
                    is OutputLine -> {
                        if (!lineIter.hasNext()) {
                            return wrongOutputSizeFeedback()
                        }


                        val result = phraseLine.checker(lineIter.next(), context)
                        if (result != CheckResult.TRUE) {
                            // add the test start to output:
                            val trimmedLines = lines.take(lineIter.nextIndex())
                            return CheckResult.FALSE("${result.feedback}\n\n" +
                                    mergeInputAndOutput(trimmedLines))
                        }
                    }
                }
            }

            if (lineIter.hasNext()) {
                return wrongOutputSizeFeedback()
            }

            return CheckResult.TRUE
        }

        /** Merge program output lines, and test input lines. */
        private fun mergeInputAndOutput(outputLines: List<String>): String {
            val lineIter = outputLines.iterator()
            val sb = StringBuilder("Your output with test input (`>` indicates test input):\n")
            for (phrase in phrases) {
                if (!lineIter.hasNext()) {
                    break
                }
                when (phrase) {
                    is OutputLine -> {
                        sb.appendln(lineIter.next())
                    }
                    is UserLine -> {
                        sb.appendln("> ${phrase.text}")
                    }
                }
            }
    // add left output
            while (lineIter.hasNext()) {
                sb.appendln(lineIter.next())
            }
            return sb.toString()
        }
    }

    fun dialogTest(vararg phrases: Phrase): TestCase<DialogClue> {
        val dialogClue = DialogClue(phrases.flatMap { it.toPhraseLines() })
        return TestCase<DialogClue>()
                .setInput(dialogClue.generateInput())
                .setAttach(dialogClue)
    }
  learner_created: false
- name: test/FlashcardsTest.java
  visible: false
  text: |
    import common.FlashcardsStage6Test;

    public class FlashcardsTest extends FlashcardsStage6Test {
        // just empty class, but not abstract so it can be run
    }
  learner_created: false
- name: src/flashcards/Main.java
  visible: true
  text: |-
    package flashcards;

    import java.io.File;
    import java.io.FileNotFoundException;
    import java.io.IOException;
    import java.io.PrintWriter;
    import java.nio.file.Files;
    import java.nio.file.Paths;
    import java.util.*;

    public class Main {
        public static LinkedHashMap<String, String> questions = new LinkedHashMap<>();

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);

            String command = "";
            System.out.println("Input the action (add, remove, import, export, ask, exit):");

            while (sc.hasNext() && !"exit".equals(command)){
                command = sc.nextLine().trim();

                if("add".equals(command)){

                    System.out.println("The card:");
                    String card = sc.nextLine();
                    if (questions.containsKey(card)){
                        System.out.println("The card \"" + card + "\" already exists.");
                    } else {
                        System.out.println("The definition of the card:");
                        String definition = sc.nextLine();
                        if (questions.containsValue(definition)){
                            System.out.println("The definition \"" + definition + "\" already exists.");
                        } else {

                            questions.put(card, definition);
                            System.out.println("The pair (\"" + card + "\":\"" + definition + "\") has been added.");
                        }
                    }

                } else if("remove".equals(command)){

                    System.out.println("The card:");
                    String card = sc.nextLine();
                    if (questions.containsKey(card)){
                        questions.remove(card);
                        System.out.println("The card has been removed.");
                    } else {
                        System.out.println("Can't remove \"" + card + "\": there is no such card.");
                    }
                } else if("import".equals(command)){
                    System.out.println("File name:");
                    String file = sc.nextLine();
                    importQuestions(new File(file));
                } else if("export".equals(command)){
                    System.out.println("File name:");
                    String file = sc.nextLine();
                    exportQuestions(new File(file));
                } else if("ask".equals(command)){
                    System.out.println("How many times to ask?:");
                    int count = Integer.parseInt(sc.nextLine());
                    while (count != 0){
                        for(Map.Entry<String, String > entry : questions.entrySet()){
                            if(count == 0){
                                break;
                            }
                            String term = entry.getKey();
                            String definition = entry.getValue();
                            System.out.println("Print the definition of \"" + term + "\":");
                            String answer = sc.nextLine();
                            if(answer.toLowerCase(Locale.ENGLISH).equals(definition.toLowerCase(Locale.ENGLISH))){
                                System.out.println("Correct answer.");
                            } else {
                                if(questions.containsValue(answer)){
                                    String anotherAnswer = "";
                                    for(Map.Entry<String, String> e : questions.entrySet()){
                                        if(e.getValue().equals(answer)){
                                                anotherAnswer = e.getKey();
                                            break;
                                        }
                                    }
                                    System.out.println("Wrong answer. The correct one is \"" + definition + "\", you've just written the definition of \"" + anotherAnswer + "\".");
                                } else {
                                    System.out.println("Wrong answer. The correct one is \"" + definition + "\".");
                                }
                            }
                            count -= 1;
                        }
                    }
                } else if("exit".equals(command)){
                    break;
                }
                System.out.println("Input the action (add, remove, import, export, ask, exit):");
            }
            System.out.println("Bye bye!");
        }
        public static void importQuestions(File file){
            int counter = 0;
            try(Scanner sc = new Scanner(file)) {
                String term;
                String definition;
                while(sc.hasNext()){
                    term = sc.nextLine();
                    if(sc.hasNext()){
                        definition = sc.nextLine();
                        questions.put(term, definition);
                        counter += 1;
                    }
                }
                System.out.println(counter + " cards have been loaded.");
            } catch (FileNotFoundException e) {
                System.out.println("File not found.");
            }
        }

        public static void exportQuestions(File file){
            int counter = 0;
            try(PrintWriter printWriter = new PrintWriter(file)){
                for(Map.Entry<String, String> e : questions.entrySet()){
                    printWriter.println(e.getKey());
                    printWriter.println(e.getValue());
                    counter += 1;
                }
                System.out.println(counter + " cards have been saved.");
            } catch (IOException e){
                System.out.println("File not found.");
            }
        }
    }
  learner_created: false
- name: capitals.txt
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/projects/44/stages/237/implement
status: Solved
record: 1
